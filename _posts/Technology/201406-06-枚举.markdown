---
layout: post
title: 枚举 sizeof #pragma_pack
category: 学习
tags: linux
keywords: linux
---
##枚举
>* 如果没有给枚举赋初值，编译器会自动为每个枚举常量赋上一个不同的初值，第一个为0，第二个为1.。。。。。。
>* 枚举表中某个常量赋值后，其后的成员则按依次加1的规则确定值


##sizeof运算符 (page 46)

##pragma pack（改变边界对齐条件）
事实上，很多人对`#pragma pack`的理解是错误的。
`#pragma pack`规定的对齐长度，实际使用的规则是：
结构，联合，或者类的数据成员，第一个放在偏移为0的地方，以后每个数据成员的对齐，按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行
也就是说，当#pragma pack的值等于或超过所有数据成员长度的时候，这个值的大小将不产生任何效果。
而结构整体的对齐，则按照结构体中最大的数据成员 和 #pragma pack指定值 之间，较小的那个进行。


##复习情况
>* 枚举 (page 45)
>* sizeof运算符 (page 46)

##复习重点问题
1.  一定要注意`sizeof`是运算符，会遇到相关复合运算问题时要特别注意（比如运算优先级的问题），需要注意在windows的VS和Linux+GCC下的多种不同情况

2.  struct的空间计算 (page 49)
    >* 注意两个原则（page 49）
    >* 含有结构体的结构体空间的计算(新的两个原则，page 51)，例题1（page 50）
    >* 含有数组的结构体的空间计算（page 51）
    >* 含有位域结构体的空间计算（page 52,5个规则）
    >* 使用`“#pragma pack”`时结构体空间的计算（page 53,需要注意`#pragma pack`的使用意义）
    >* 空结构体的大小（page 54）
    >* 例题1（page 49）
    >* [网络参考资料](http://blog.sina.com.cn/s/blog_5a42533f01017z0l.html)
    >* 对于结构体的空间计算，不管是包含结构体，位域，数组，pragma pack，都要注意对齐的问题，都是 **选择结构体中长度最大的数据类型为标准进行对齐**
3.  union的空间计算
    >* 例2(page 54)

4.  习题
    >* 1 (page 55,又见大端小端)
    >* 19(page 61, **位域的问题** （位域会进行压缩）)
    >* 21(page 62)
