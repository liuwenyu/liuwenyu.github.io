<!doctype html>
<html>
<head>
  <meta charset="utf-8">
<title>epoll | 落枫的博客</title>
<meta name="author" content="">

  <meta name="keywords" content="linux">


<link rel="shortcut icon" href="/public/upload/gavatar/favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/public/css/bootstrap.css">
<link rel="stylesheet" href="/public/css/font-awesome.css">
<link rel="stylesheet" href="/public/js/prettify/prettify.css">
<link rel="stylesheet" href="/public/css/base.css">
<!--<link href="/pages/atom.xml" rel="alternate" title="落枫的博客" type="application/atom+xml"> -->
</head>
<body>
  <div class="container">
    <div class="row">
      <div class="col-md-4 col-lg-4 col-sm-12 col-xs-12 aside visible-md visible-lg">
  <div class="row">
    <div class="col-md-3 col-xs-3 aside1">
      <br>
      <a class="pjaxlink" href="/"><img src="/public/upload/gavatar/gavatar.png" class="img-rounded avatar"></a>
      <br><br>
      <ul class="nav nav-pills nav-stacked">
        
          <li><a href="#学习" data-toggle="tab">学习</a></li>
        
          <li><a href="#技术学习" data-toggle="tab">技术学习</a></li>
        
          <li><a href="#面试必备" data-toggle="tab">面试必备</a></li>
        
        <li><a href="#tags" data-toggle="tab">标签</a></li>
        <!--        <li><a class="pjaxlink" href="/pages/about.html">关于</a></li>-->
      </ul>
      <div class="aside1_bottom">
        <!--
        <table class="table table-condensed">
          <tr>
            <td><a href="/pages/atom.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a></td>
            <td><a href="mailto:liuwenyu21@gmail.com"><i class="fa fa-envelope-o fa-2x"></i></a></td>
          </tr>
        </table>
      -->
        <!--
      <img src="" class="img-rounded weixin">
      -->
      </div>
    </div>
    <div class="col-md-9 col-xs-9 aside2">
      <div class="row">
        <div class="tab-content">
           
            <div class="tab-pane" id="学习">
              <div class="list-group">
                <h2 class="center">学习</h2>
                
                  <a href="/2014/06/16/%E9%93%BE%E8%A1%A8.html" class="list-group-item pjaxlink">二叉树 链表</a>
                
                  <a href="/2014/06/15/fork.html" class="list-group-item pjaxlink">多进程 fork</a>
                
                  <a href="/2014/06/14/sql.html" class="list-group-item pjaxlink">MySql</a>
                
                  <a href="/2014/06/13/%E6%8E%92%E5%BA%8F.html" class="list-group-item pjaxlink">排序 查找 键树 结构体</a>
                
                  <a href="/2014/06/10/%E9%87%8D%E8%BD%BD.html" class="list-group-item pjaxlink">重载 虚函数 动态绑定</a>
                
                  <a href="/2014/06/07/%E9%80%92%E5%BD%92.html" class="list-group-item pjaxlink">递归 宏定义 内联函数</a>
                
                  <a href="/2014/06/06/%E6%9E%9A%E4%B8%BE.html" class="list-group-item pjaxlink">枚举 sizeof</a>
                
                  <a href="/2014/06/04/%E8%81%94%E5%90%88%E4%BD%93.html" class="list-group-item pjaxlink">联合体 大端小端 位域 指针引用</a>
                
                  <a href="/2014/06/02/volatile.html" class="list-group-item pjaxlink">全局变量 volatile</a>
                
                  <a href="/2014/05/30/const%E4%B8%8E%E6%8C%87%E9%92%88.html" class="list-group-item pjaxlink">const与指针 函数返回值 声明</a>
                
                  <a href="/2014/05/03/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.html" class="list-group-item pjaxlink">UDP服务器 僵尸进程</a>
                
                  <a href="/2014/05/02/%E6%80%BB%E7%BB%93.html" class="list-group-item pjaxlink">学习总结</a>
                
                  <a href="/2014/05/01/%E8%99%9A%E7%BB%A7%E6%89%BF.html" class="list-group-item pjaxlink">约瑟夫问题 虚继承</a>
                
                  <a href="/2014/04/30/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html" class="list-group-item pjaxlink">构造函数</a>
                
                  <a href="/2014/04/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html" class="list-group-item pjaxlink">内存 线程池</a>
                
                  <a href="/2014/04/24/c++.html" class="list-group-item pjaxlink">c++</a>
                
                  <a href="/2014/04/23/%E5%86%85%E5%AD%98.html" class="list-group-item pjaxlink">内存 复制控制</a>
                
                  <a href="/2014/04/22/%E7%BB%A7%E6%89%BF.html" class="list-group-item pjaxlink">继承 函数重载覆盖隐藏</a>
                
                  <a href="/2014/04/21/string.html" class="list-group-item pjaxlink">重载运算符-智能指针-String</a>
                
                  <a href="/2014/04/18/%E5%A4%8D%E5%88%B6%E6%8E%A7%E5%88%B6.html" class="list-group-item pjaxlink">复制控制</a>
                
                  <a href="/2014/04/17/map.html" class="list-group-item pjaxlink">Linux网络编程 map</a>
                
                  <a href="/2014/04/16/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html" class="list-group-item pjaxlink">工厂模式</a>
                
                  <a href="/2014/04/15/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%94%9F%E4%BA%A7%E8%80%85.html" class="list-group-item pjaxlink">UDP服务器 生产者</a>
                
                  <a href="/2014/04/14/%E7%BA%BF%E7%A8%8B.html" class="list-group-item pjaxlink">线程</a>
                
                  <a href="/2014/04/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html" class="list-group-item pjaxlink">设计模式 单例模式</a>
                
                  <a href="/2014/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83.html" class="list-group-item pjaxlink">进程 线程</a>
                
                  <a href="/2014/04/04/Socket-TCP.html" class="list-group-item pjaxlink">Socket TCP</a>
                
                  <a href="/2014/04/03/linux(UDP).html" class="list-group-item pjaxlink">基于UDP的多人群聊</a>
                
                  <a href="/2014/04/02/Linux.html" class="list-group-item pjaxlink">Linux网络编程 socket UDP</a>
                
                  <a href="/2014/04/01/Linux.html" class="list-group-item pjaxlink">大端小端 ip转换</a>
                
                  <a href="/2014/03/31/pthread.html" class="list-group-item pjaxlink">pthread</a>
                
              </div>
            </div>
           
            <div class="tab-pane" id="技术学习">
              <div class="list-group">
                <h2 class="center">技术学习</h2>
                
                  <a href="/2014/06/19/%E5%9F%BA%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E6%B5%8F%E8%A7%88%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8.html" class="list-group-item pjaxlink">FTP文件服务器 项目</a>
                
                  <a href="/2014/06/01/%E5%AD%A6%E4%B9%A0%E9%87%8D%E7%82%B9.html" class="list-group-item pjaxlink">学习方向与重点</a>
                
                  <a href="/2014/05/26/MiniSearchEngine%E6%80%BB%E7%BB%93.html" class="list-group-item pjaxlink">MiniSearchEngine总结</a>
                
                  <a href="/2014/05/24/minisearchengin.html" class="list-group-item pjaxlink">MiniSearchEngine 项目</a>
                
                  <a href="/2014/05/22/SpellCorrector.html" class="list-group-item pjaxlink">SpellCorrector 项目</a>
                
                  <a href="/2014/05/05/epoll%E8%AF%A6%E8%A7%A3.html" class="list-group-item pjaxlink">epoll</a>
                
                  <a href="/2014/05/02/mini%E6%90%9C%E7%B4%A2.html" class="list-group-item pjaxlink">mini搜索</a>
                
              </div>
            </div>
           
            <div class="tab-pane" id="面试必备">
              <div class="list-group">
                <h2 class="center">面试必备</h2>
                
                  <a href="/2014/06/20/c++300.html" class="list-group-item pjaxlink">c++笔试300题</a>
                
              </div>
            </div>
          
          <div class="tab-pane" id="tags">
            <div class="panel-group" id="accordion">
              <h2 class="center">标签</h2>
               
                <div class="panel panel-info">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" data-toggle="collapse" data-parent="#accordion" href="#linux">linux</a>
                      <span class="badge pull-right">36</span>
                    </h4>
                  </div>
                  <div id="linux" class="panel-collapse collapse">
                    
                      <a  href='/2014/06/19/%E5%9F%BA%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E6%B5%8F%E8%A7%88%E5%92%8C%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8.html' class="list-group-item pjaxlink">
                        FTP文件服务器 项目
                      </a>
                    
                      <a  href='/2014/06/16/%E9%93%BE%E8%A1%A8.html' class="list-group-item pjaxlink">
                        二叉树 链表
                      </a>
                    
                      <a  href='/2014/06/15/fork.html' class="list-group-item pjaxlink">
                        多进程 fork
                      </a>
                    
                      <a  href='/2014/06/13/%E6%8E%92%E5%BA%8F.html' class="list-group-item pjaxlink">
                        排序 查找 键树 结构体
                      </a>
                    
                      <a  href='/2014/06/10/%E9%87%8D%E8%BD%BD.html' class="list-group-item pjaxlink">
                        重载 虚函数 动态绑定
                      </a>
                    
                      <a  href='/2014/06/07/%E9%80%92%E5%BD%92.html' class="list-group-item pjaxlink">
                        递归 宏定义 内联函数
                      </a>
                    
                      <a  href='/2014/06/06/%E6%9E%9A%E4%B8%BE.html' class="list-group-item pjaxlink">
                        枚举 sizeof
                      </a>
                    
                      <a  href='/2014/06/04/%E8%81%94%E5%90%88%E4%BD%93.html' class="list-group-item pjaxlink">
                        联合体 大端小端 位域 指针引用
                      </a>
                    
                      <a  href='/2014/06/02/volatile.html' class="list-group-item pjaxlink">
                        全局变量 volatile
                      </a>
                    
                      <a  href='/2014/06/01/%E5%AD%A6%E4%B9%A0%E9%87%8D%E7%82%B9.html' class="list-group-item pjaxlink">
                        学习方向与重点
                      </a>
                    
                      <a  href='/2014/05/30/const%E4%B8%8E%E6%8C%87%E9%92%88.html' class="list-group-item pjaxlink">
                        const与指针 函数返回值 声明
                      </a>
                    
                      <a  href='/2014/05/26/MiniSearchEngine%E6%80%BB%E7%BB%93.html' class="list-group-item pjaxlink">
                        MiniSearchEngine总结
                      </a>
                    
                      <a  href='/2014/05/24/minisearchengin.html' class="list-group-item pjaxlink">
                        MiniSearchEngine 项目
                      </a>
                    
                      <a  href='/2014/05/22/SpellCorrector.html' class="list-group-item pjaxlink">
                        SpellCorrector 项目
                      </a>
                    
                      <a  href='/2014/05/05/epoll%E8%AF%A6%E8%A7%A3.html' class="list-group-item pjaxlink">
                        epoll
                      </a>
                    
                      <a  href='/2014/05/03/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.html' class="list-group-item pjaxlink">
                        UDP服务器 僵尸进程
                      </a>
                    
                      <a  href='/2014/05/02/%E6%80%BB%E7%BB%93.html' class="list-group-item pjaxlink">
                        学习总结
                      </a>
                    
                      <a  href='/2014/05/02/mini%E6%90%9C%E7%B4%A2.html' class="list-group-item pjaxlink">
                        mini搜索
                      </a>
                    
                      <a  href='/2014/05/01/%E8%99%9A%E7%BB%A7%E6%89%BF.html' class="list-group-item pjaxlink">
                        约瑟夫问题 虚继承
                      </a>
                    
                      <a  href='/2014/04/30/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.html' class="list-group-item pjaxlink">
                        构造函数
                      </a>
                    
                      <a  href='/2014/04/25/%E7%BA%BF%E7%A8%8B%E6%B1%A0.html' class="list-group-item pjaxlink">
                        内存 线程池
                      </a>
                    
                      <a  href='/2014/04/24/c++.html' class="list-group-item pjaxlink">
                        c++
                      </a>
                    
                      <a  href='/2014/04/23/%E5%86%85%E5%AD%98.html' class="list-group-item pjaxlink">
                        内存 复制控制
                      </a>
                    
                      <a  href='/2014/04/22/%E7%BB%A7%E6%89%BF.html' class="list-group-item pjaxlink">
                        继承 函数重载覆盖隐藏
                      </a>
                    
                      <a  href='/2014/04/21/string.html' class="list-group-item pjaxlink">
                        重载运算符-智能指针-String
                      </a>
                    
                      <a  href='/2014/04/18/%E5%A4%8D%E5%88%B6%E6%8E%A7%E5%88%B6.html' class="list-group-item pjaxlink">
                        复制控制
                      </a>
                    
                      <a  href='/2014/04/17/map.html' class="list-group-item pjaxlink">
                        Linux网络编程 map
                      </a>
                    
                      <a  href='/2014/04/16/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html' class="list-group-item pjaxlink">
                        工厂模式
                      </a>
                    
                      <a  href='/2014/04/15/UDP%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%94%9F%E4%BA%A7%E8%80%85.html' class="list-group-item pjaxlink">
                        UDP服务器 生产者
                      </a>
                    
                      <a  href='/2014/04/14/%E7%BA%BF%E7%A8%8B.html' class="list-group-item pjaxlink">
                        线程
                      </a>
                    
                      <a  href='/2014/04/11/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html' class="list-group-item pjaxlink">
                        设计模式 单例模式
                      </a>
                    
                      <a  href='/2014/04/04/Socket-TCP.html' class="list-group-item pjaxlink">
                        Socket TCP
                      </a>
                    
                      <a  href='/2014/04/03/linux(UDP).html' class="list-group-item pjaxlink">
                        基于UDP的多人群聊
                      </a>
                    
                      <a  href='/2014/04/02/Linux.html' class="list-group-item pjaxlink">
                        Linux网络编程 socket UDP
                      </a>
                    
                      <a  href='/2014/04/01/Linux.html' class="list-group-item pjaxlink">
                        大端小端 ip转换
                      </a>
                    
                      <a  href='/2014/03/31/pthread.html' class="list-group-item pjaxlink">
                        pthread
                      </a>
                    
                  </div>
                </div>
               
                <div class="panel panel-info">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" data-toggle="collapse" data-parent="#accordion" href="#总结">总结</a>
                      <span class="badge pull-right">1</span>
                    </h4>
                  </div>
                  <div id="总结" class="panel-collapse collapse">
                    
                      <a  href='/2014/04/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83.html' class="list-group-item pjaxlink">
                        进程 线程
                      </a>
                    
                  </div>
                </div>
               
                <div class="panel panel-info">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" data-toggle="collapse" data-parent="#accordion" href="#MySql">MySql</a>
                      <span class="badge pull-right">1</span>
                    </h4>
                  </div>
                  <div id="MySql" class="panel-collapse collapse">
                    
                      <a  href='/2014/06/14/sql.html' class="list-group-item pjaxlink">
                        MySql
                      </a>
                    
                  </div>
                </div>
               
                <div class="panel panel-info">
                  <div class="panel-heading">
                    <h4 class="panel-title">
                      <a data-toggle="collapse" data-toggle="collapse" data-parent="#accordion" href="#linux/C/C++">linux/C/C++</a>
                      <span class="badge pull-right">1</span>
                    </h4>
                  </div>
                  <div id="linux/C/C++" class="panel-collapse collapse">
                    
                      <a  href='/2014/06/20/c++300.html' class="list-group-item pjaxlink">
                        c++笔试300题
                      </a>
                    
                  </div>
                </div>
              
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

      <div class="col-md-8 col-lg-8 col-sm-12 col-xs-12 aside3">
        <div id="container">
          <div id="pjax">
            <div class="row">
  <div class="col-md-12 aside3-title">
    <br>
    <h2 id="#identifier">epoll</h2>
    2014年05月05日
  </div>
  <div class="col-md-12 aside3-content">
    <hr>
    <div id="content">
      <h2>什么是epoll</h2>

<p><code>epoll</code>是什么？按照man手册的说法：是为处理大批量句柄而作了改进的poll。当然，这不是2.6内核才有的，它是在2.5.44内核中被引进的(epoll(4) is a new API introduced in Linux kernel 2.5.44)，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</p>

<h2>epoll的相关系统调用</h2>

<p>epoll只有<code>epoll_create</code>,<code>epoll_ctl</code>,<code>epoll_wait</code> 3个系统调用。</p>

<ol>
<li><p><code>int epoll_create(int size);</code>
创建一个epoll的句柄。自从linux2.6.8之后，size参数是被忽略的。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p></li>
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code>
epoll的事件注册函数，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。
第一个参数是epoll<em>create()的返回值。
第二个参数表示动作，用三个宏来表示：
EPOLL</em>CTL<em>ADD：注册新的fd到epfd中；
EPOLL</em>CTL<em>MOD：修改已经注册的fd的监听事件；
EPOLL</em>CTL<em>DEL：从epfd中删除一个fd；
第三个参数是需要监听的fd。
第四个参数是告诉内核需要监听什么事，struct epoll</em>event结构如下：</p></li>
</ol>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="c1">//保存触发事件的某个文件描述符相关的数据（与具体使用方式有关）  </span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span> <span class="p">{</span>  
    <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>  
    <span class="kt">__uint32_t</span> <span class="n">u32</span><span class="p">;</span>  
    <span class="kt">__uint64_t</span> <span class="n">u64</span><span class="p">;</span>  
<span class="p">}</span> <span class="kt">epoll_data_t</span><span class="p">;</span>  
 <span class="c1">//感兴趣的事件和被触发的事件  </span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>  
    <span class="kt">__uint32_t</span> <span class="n">events</span><span class="p">;</span> <span class="cm">/* Epoll events */</span>  
    <span class="kt">epoll_data_t</span> <span class="n">data</span><span class="p">;</span> <span class="cm">/* User data variable */</span>  
<span class="p">};</span>  
</code></pre></div>
<p>events可以是以下几个宏的集合：</p>

<blockquote>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
</blockquote>

<ol>
<li> <code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code>
收集在epoll监控的事件中已经发送的事件。参数events是分配好的epoll<em>event结构体数组，epoll将会把发生的事件赋值到events数组中（events不可以是空指针，内核只负责把数据复制到这个events数组中，不会去帮助我们在用户态中分配内存）。maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll</em>create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。如果函数调用成功，返回对应I/O上已准备好的文件描述符数目，如返回0表示已超时。</li>
</ol>

<h2>epoll工作原理</h2>

<p>　epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了<code>内存映射（mmap）技术</code>，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。</p>

<p>　另一个本质的改进在于·epoll采用基于事件的就绪通知方式·。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll<em>ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll</em>wait()时便得到通知。</p>

<h2>Epoll的2种工作方式-水平触发（LT）和边缘触发（ET）</h2>

<p>假如有这样一个例子：
1. 我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符
2. 这个时候从管道的另一端被写入了2KB的数据
3. 调用epoll<em>wait(2)，并且它会返回RFD，说明它已经准备好读取操作
4. 然后我们读取了1KB的数据
5. 调用epoll</em>wait(2)......</p>

<h2>Edge Triggered 工作模式：</h2>

<p>如果我们在第1步将RFD添加到<code>epoll</code>描述符的时候使用了<code>EPOLLET</code>标志，那么在第5步调用<code>epoll_wait(2)</code>之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 <code>ET 工作模式</code>才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。在上面的例子中，会有一个事件产生在<code>RFD句柄</code>上，因为在第2步执行了一个写操作，然后，事件将会在第3步被销毁。因为第4步的读取操作没有读空文件输入缓冲区内的数据，因此我们在第5步调用 <code>epoll_wait(2)</code>完成后，是否挂起是不确定的。<code>epoll</code>工作在<code>ET模式</code>的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用<code>ET模式</code>的<code>epoll</code>接口，在后面会介绍避免可能的缺陷。</p>

<blockquote>
<ul>
<li>i.  基于非阻塞文件句柄</li>
<li>ii. 只有当<code>read(2)</code>或者<code>write(2)</code>返回<code>EAGAIN</code>时才需要挂起，等待。但这并不是说每次<code>read()</code>时</li>
</ul>
</blockquote>

<p>都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read()返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。</p>

<h2>Level Triggered 工作模式</h2>

<p>相反的，以<code>LT方式</code>调用<code>epoll</code>接口的时候，它就相当于一个速度比较快的<code>poll(2)</code>，并且无论后面的数据是否被使用，因此他们具有同样的职能。因为即使使用<code>ET模式</code>的<code>epoll</code>，在收到多个<code>chunk</code>的数据的时候仍然会产生多个事件。调用者可以设定<code>EPOLLONESHOT</code>标志，在<code>epoll_wait(2)</code>收到事件后<code>epoll</code>会与事件关联的文件句柄从<code>epoll</code>描述符中禁止掉。因此当<code>EPOLLONESHOT</code>设定后，使用带有 <code>EPOLL_CTL_MOD</code>标志的<code>epoll_ctl(2)</code>处理文件句柄就成为调用者必须作的事情。</p>

<p><code>LT(level triggered)是epoll缺省的工作方式</code>，并且同时支持<code>block</code>和<code>no-block socket</code>.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你 的，所以，这种模式编程出错误可能性要小一点。传统的<code>select/poll</code>都是这种模型的代表．</p>

<p><code>ET (edge-triggered)是高速工作方式，只支持no-block socket，它效率要比LT更高</code>。<code>ET与LT的区别</code>在于，当一个新的事件到来时，<code>ET模式</code>下当然可以从<code>epoll_wait</code>调用中获取到这个事件，可是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字中没有新的事件再次到来时，在ET模式下是无法再次从<code>epoll_wait</code>调用中获取这个事件的。而<code>LT模式</code>正好相反，只要一个事件对应的套接字缓冲区还有数据，就总能从<code>epoll_wait</code>中获取这个事件。
因此，<code>LT模式</code>下开发基于<code>epoll</code>的应用要简单些，不太容易出错。而在<code>ET模式</code>下事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应。</p>

<p>图示说明：</p>

<p><img src="http://img.blog.csdn.net/20130705114312171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhanVuMDcwNjEyMjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="图示说明"></p>

<p><code>Nginx</code>(流行的高性能网络服务器)默认采用<code>ET模式</code>来使用<code>epoll</code>。</p>

<h2>epoll的优点：</h2>

<ol>
<li><p>支持一个进程打开大数目的socket描述符(FD)</p>

<blockquote>
<p><code>select</code> 最不能忍受的是一个进程所打开的FD是有一定限制的，由<code>FD_SETSIZE</code>设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。不过 <code>epoll</code><code>则没有这个限制，它所支持的FD上限是最大可以打开文件的数目</code>，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看,一般来说这个数目和系统内存关系很大。</p>
</blockquote></li>
<li><p>IO效率不随FD数目增加而线性下降</p>

<blockquote>
<p>传统的<code>select/poll</code>另一个致命弱点就是当你拥有一个很大的<code>socket</code>集合，不过由于网络延时，任一时间只有部分的<code>socket</code>是&quot;活跃&quot;的，但是<code>select/poll</code>每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它<code>只会对&quot;活跃&quot;的socket进行操作</code>---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有&quot;活跃&quot;的<code>socket</code>才会主动的去调用 <code>callback</code>函数，其他<code>idle</code>状态<code>socket</code>则不会，在这点上，<code>epoll</code>实现了一个<code>&quot;伪&quot;AIO</code>，因为这时候推动力在os内核。在一些 <code>benchmark</code>中，如果所有的<code>socket</code>基本上都是活跃的---比如一个高速LAN环境，<code>epoll</code>并不比<code>select/poll</code>有什么效率，相反，如果过多使用<code>epoll_ctl</code>,效率相比还有稍微的下降。但是一旦使用<code>idle connections</code>模拟WAN环境,<code>epoll</code>的效率就远在<code>select/poll</code>之上了。</p>
</blockquote></li>
<li><p>使用mmap加速内核与用户空间的消息传递</p>

<blockquote>
<p>这点实际上涉及到<code>epoll</code>的具体实现了。无论是<code>select</code>,<code>poll</code>还是<code>epoll都需要内核把FD消息通知给用户空间</code>，如何避免不必要的内存拷贝就很重要，在这点上，<code>epoll</code>是通过内核于用户空间<code>mmap</code>同一块内存实现的。而如果你想我一样从2.5内核就关注<code>epoll</code>的话，一定不会忘记手工<code>mmap</code>这一步的。</p>
</blockquote></li>
<li><p>内核微调</p>

<blockquote>
<p>这一点其实不算<code>epoll</code>的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。比如，内核TCP/IP协议栈使用<code>内存池</code>管理<code>sk_buff</code>结构，那么可以在运行时期动态调整这个内存<code>pool(skb_head_pool)</code>的大小--- 通过<code>echo XXXX&gt;/proc/sys/net/core/hot_list_length</code>完成。再比如<code>listen</code>函数的第2个参数(TCP完成3次握手的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网卡驱动架构。</p>
</blockquote></li>
</ol>

<h2>linux下epoll如何实现高效处理百万句柄的</h2>

<p>开发高性能网络程序时，windows开发者们言必称iocp，linux开发者们则言必称epoll。大家都明白<code>epoll</code>是一种IO多路复用技术，可以非常高效的处理数以百万计的<code>socket</code>句柄，比起以前的<code>select</code>和<code>poll</code>效率高大发了。我们用起<code>epoll</code>来都感觉挺爽，确实快，那么，它到底为什么可以高速处理这么多并发连接呢？</p>

<blockquote>
<ul>
<li><p>使用起来很清晰，首先要调用<code>epoll_create</code>建立一个<code>epoll</code>对象。参数<code>size</code>是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</p></li>
<li><p><code>epoll_ctl</code>可以操作上面建立的epoll，例如，将刚建立的<code>socket</code>加入到<code>epoll</code>中让其监控，或者把 <code>epoll</code>正在监控的某个<code>socket</code>句柄移出<code>epoll</code>，不再监控它等等。</p></li>
<li><p><code>epoll_wait</code>在调用时，在给定的<code>timeout</code>时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程。</p></li>
</ul>
</blockquote>

<p>从上面的调用方式就可以看到<code>epoll</code>比<code>select/poll</code>的优越之处：<code>因为后者每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态</code>，如果以万计的<code>句柄</code>会导致每次都要copy几十几百KB的内存到内核态，非常低效。而我们调用<code>epoll_wait</code>时就相当于以往调用<code>select/poll</code>，但是<code>这时却不用传递socket句柄</code>给内核，因为内核已经在<code>epoll_ctl</code>中拿到了要监控的句柄列表`。</p>

<p>所以，实际上在你调用<code>epoll_create</code>后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用<code>epoll_ctl</code>只是在往内核的数据结构里塞入新的<code>socket句柄</code>。
当一个进程调用<code>epoll_create</code>方法时，Linux内核会创建一个<code>eventpoll</code>结构体，这个结构体中有两个成员与<code>epoll</code>的使用方式密切相关：</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="cp">#include&lt;stdio.h&gt;</span>
<span class="cm">/* </span>
<span class="cm"> * This structure is stored inside the &quot;private_data&quot; member of the file </span>
<span class="cm"> * structure and represents the main data structure for the eventpoll </span>
<span class="cm"> * interface. </span>
<span class="cm">*/</span>  
<span class="k">struct</span> <span class="n">eventpoll</span> <span class="p">{</span>  
    <span class="cm">/* Protect the access to this structure */</span>  
    <span class="kt">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>  
    <span class="cm">/* </span>
<span class="cm">     * This mutex is used to ensure that files are not removed </span>
<span class="cm">     * while epoll is using them. This is held during the event </span>
<span class="cm">     * collection loop, the file cleanup path, the epoll file exit </span>
<span class="cm">     * code and the ctl operations. </span>
<span class="cm">*/</span>  
    <span class="k">struct</span> <span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>  
    <span class="cm">/* Wait queue used by sys_epoll_wait() */</span>  
    <span class="kt">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>  
    <span class="cm">/* Wait queue used by file-&gt;poll() */</span>  
    <span class="kt">wait_queue_head_t</span> <span class="n">poll_wait</span><span class="p">;</span>  
    <span class="cm">/* List of ready file descriptors */</span>  
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllist</span><span class="p">;</span>  
    <span class="cm">/* RB tree root used to store monitored fd structs */</span>  
    <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rbr</span><span class="p">;</span><span class="c1">//红黑树根节点，这棵树存储着所有添加到epoll中的事件，也就是这个epoll监控的事件  </span>
    <span class="cm">/* </span>
<span class="cm">     * This is a single linked list that chains all the &quot;struct epitem&quot; that </span>
<span class="cm">     * happened while transferring ready events to userspace w/out </span>
<span class="cm">     * holding -&gt;lock. </span>
<span class="cm">     */</span>  
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">ovflist</span><span class="p">;</span>  
    <span class="cm">/* wakeup_source used when ep_scan_ready_list is running */</span>  
    <span class="k">struct</span> <span class="n">wakeup_source</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>  
    <span class="cm">/* The user that created the eventpoll descriptor */</span>  
    <span class="k">struct</span> <span class="n">user_struct</span> <span class="o">*</span><span class="n">user</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>  
    <span class="cm">/* used to optimize loop detection check */</span>  
    <span class="kt">int</span> <span class="n">visited</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">visited_list_link</span><span class="p">;</span><span class="c1">//双向链表中保存着将要通过epoll_wait返回给用户的、满足条件的事件  </span>
<span class="p">};</span>  
</code></pre></div>
<p>每一个epoll对象都有一个独立的eventpoll结构体，这个结构体会在内核空间中创造独立的内存，用于存储使用epoll_ctl方法向epoll对象中添加进来的事件。这样，重复的事件就可以通过红黑树而高效的识别出来。
在epoll中，对于每一个事件都会建立一个epitem结构体：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* </span>
<span class="cm"> * Each file descriptor added to the eventpoll interface will </span>
<span class="cm"> * have an entry of this type linked to the &quot;rbr&quot; RB tree. </span>
<span class="cm"> * Avoid increasing the size of this struct, there can be many thousands </span>
<span class="cm"> * of these on a server and we do not want this to take another cache line. </span>
<span class="cm"> */</span>  
<span class="k">struct</span> <span class="n">epitem</span> <span class="p">{</span>  
    <span class="cm">/* RB tree node used to link this structure to the eventpoll RB tree */</span>  
    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbn</span><span class="p">;</span>  
    <span class="cm">/* List header used to link this structure to the eventpoll ready list */</span>  
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdllink</span><span class="p">;</span>  
    <span class="cm">/* </span>
<span class="cm">     * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the </span>
<span class="cm">     * single linked chain of items. </span>
<span class="cm">     */</span>  
    <span class="k">struct</span> <span class="n">epitem</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>  
    <span class="cm">/* The file descriptor information this item refers to */</span>  
    <span class="k">struct</span> <span class="n">epoll_filefd</span> <span class="n">ffd</span><span class="p">;</span>  
    <span class="cm">/* Number of active wait queue attached to poll operations */</span>  
    <span class="kt">int</span> <span class="n">nwait</span><span class="p">;</span>  
    <span class="cm">/* List containing poll wait queues */</span>  
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">pwqlist</span><span class="p">;</span>  
    <span class="cm">/* The &quot;container&quot; of this item */</span>  
    <span class="k">struct</span> <span class="n">eventpoll</span> <span class="o">*</span><span class="n">ep</span><span class="p">;</span>  
    <span class="cm">/* List header used to link this item to the &quot;struct file&quot; items list */</span>  
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">fllink</span><span class="p">;</span>  
    <span class="cm">/* wakeup_source used when EPOLLWAKEUP is set */</span>  
    <span class="k">struct</span> <span class="n">wakeup_source</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">ws</span><span class="p">;</span>  
    <span class="cm">/* The structure that describe the interested events and the source fd */</span>  
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>  
<span class="p">};</span>
</code></pre></div>
<p>而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已，如何能不高效？！</p>

<p>那么，这个准备就绪list链表是怎么维护的呢？<code>当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里</code>。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p>

<p>如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll<em>create时，创建了红黑树和就绪链表，执行epoll</em>ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p>

<h2>epoll的使用方法</h2>

<p>那么究竟如何来使用epoll呢？其实非常简单。</p>

<p>通过在包含一个头文件#include <sys/epoll.h> 以及几个简单的API将可以大大的提高你的网络服务器的支持人数。</p>

<p>首先通过create_epoll(int maxfds)来创建一个epoll的句柄。这个函数会返回一个新的epoll句柄，之后的所有操作将通过这个句柄来进行操作。在用完之后，记得用close()来关闭这个创建出来的epoll句柄。</p>

<p>之后在你的网络主循环里面，每一帧的调用epoll<em>wait(int epfd, epoll</em>event events, int max events, int timeout)来查询所有的网络接口，看哪一个可以读，哪一个可以写了。基本的语法为：
nfds = epoll_wait(kdpfd, events, maxevents, -1);</p>

<p>其中kdpfd为用epoll<em>create创建之后的句柄，events是一个epoll</em>event*的指针，当epoll<em>wait这个函数操作成功之后，epoll</em>events里面将储存所有的读写事件。max<em>events是当前需要监听的所有socket句柄数。最后一个timeout是 epoll</em>wait的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，直到有事件返回，为任意正整数的时候表示等这么长的时间，如果一直没有事件，则返回。一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率。</p>

<p>epoll_wait返回之后应该是一个循环，遍历所有的事件。</p>

<p>几乎所有的epoll程序都使用下面的框架：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span>  
   <span class="p">{</span>  
       <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span><span class="n">events</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">500</span><span class="p">);</span>  
       <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nfds</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>  
       <span class="p">{</span>  
           <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="o">==</span><span class="n">listenfd</span><span class="p">)</span> <span class="c1">//有新的连接  </span>
           <span class="p">{</span>  
               <span class="n">connfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,(</span><span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clilen</span><span class="p">);</span> <span class="c1">//accept这个连接  </span>
               <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="o">=</span><span class="n">connfd</span><span class="p">;</span>  
               <span class="n">ev</span><span class="p">.</span><span class="n">events</span><span class="o">=</span><span class="n">EPOLLIN</span><span class="o">|</span><span class="n">EPOLLET</span><span class="p">;</span>  
               <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span><span class="n">EPOLL_CTL_ADD</span><span class="p">,</span><span class="n">connfd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span> <span class="c1">//将新的fd添加到epoll的监听队列中  </span>
           <span class="p">}</span>  

           <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="o">&amp;</span><span class="n">EPOLLIN</span> <span class="p">)</span> <span class="c1">//接收到数据，读socket  </span>
           <span class="p">{</span>  
               <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span>    <span class="c1">//读  </span>
               <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">md</span><span class="p">;</span>     <span class="c1">//md为自定义类型，添加数据  </span>
               <span class="n">ev</span><span class="p">.</span><span class="n">events</span><span class="o">=</span><span class="n">EPOLLOUT</span><span class="o">|</span><span class="n">EPOLLET</span><span class="p">;</span>  
               <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span><span class="n">sockfd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span><span class="c1">//修改标识符，等待下一个循环时发送数据，异步处理的精髓  </span>
           <span class="p">}</span>  
           <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="o">&amp;</span><span class="n">EPOLLOUT</span><span class="p">)</span> <span class="c1">//有数据待发送，写socket  </span>
           <span class="p">{</span>  
               <span class="k">struct</span> <span class="n">myepoll_data</span><span class="o">*</span> <span class="n">md</span> <span class="o">=</span> <span class="p">(</span><span class="n">myepoll_data</span><span class="o">*</span><span class="p">)</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>    <span class="c1">//取数据  </span>
               <span class="n">sockfd</span> <span class="o">=</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>  
               <span class="n">send</span><span class="p">(</span> <span class="n">sockfd</span><span class="p">,</span> <span class="n">md</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">strlen</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">md</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">),</span> <span class="mi">0</span> <span class="p">);</span>        <span class="c1">//发送数据  </span>
               <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="o">=</span><span class="n">sockfd</span><span class="p">;</span>  
               <span class="n">ev</span><span class="p">.</span><span class="n">events</span><span class="o">=</span><span class="n">EPOLLIN</span><span class="o">|</span><span class="n">EPOLLET</span><span class="p">;</span>  
               <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span><span class="n">sockfd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span> <span class="c1">//修改标识符，等待下一个循环时接收数据  </span>
           <span class="p">}</span>  
           <span class="k">else</span>  
           <span class="p">{</span>  
               <span class="c1">//其他的处理  </span>
           <span class="p">}</span>  
       <span class="p">}</span>  
   <span class="p">}</span>  
</code></pre></div>
<h2>epoll的程序实例</h2>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;  </span>
<span class="cp">#include &lt;stdlib.h&gt;  </span>
<span class="cp">#include &lt;unistd.h&gt;  </span>
<span class="cp">#include &lt;errno.h&gt;  </span>
<span class="cp">#include &lt;sys/socket.h&gt;  </span>
<span class="cp">#include &lt;netdb.h&gt;  </span>
<span class="cp">#include &lt;fcntl.h&gt;  </span>
<span class="cp">#include &lt;sys/epoll.h&gt;  </span>
<span class="cp">#include &lt;string.h&gt;  </span>
<span class="cp">#define MAXEVENTS 64  </span>
<span class="c1">//函数:  </span>
<span class="c1">//功能:创建和绑定一个TCP socket  </span>
<span class="c1">//参数:端口  </span>
<span class="c1">//返回值:创建的socket  </span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_and_bind</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span> <span class="n">sfd</span><span class="p">;</span>  
    <span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>  
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_family</span> <span class="o">=</span> <span class="n">AF_UNSPEC</span><span class="p">;</span>     <span class="cm">/* Return IPv4 and IPv6 choices */</span>  
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="cm">/* We want a TCP socket */</span>  
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span><span class="p">;</span>     <span class="cm">/* All interfaces */</span>  
    <span class="n">s</span> <span class="o">=</span> <span class="n">getaddrinfo</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;getaddrinfo: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gai_strerror</span> <span class="p">(</span><span class="n">s</span><span class="p">));</span>  
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">for</span> <span class="p">(</span><span class="n">rp</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span> <span class="n">rp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">sfd</span> <span class="o">=</span> <span class="n">socket</span> <span class="p">(</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">);</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">sfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
            <span class="k">continue</span><span class="p">;</span>  
        <span class="n">s</span> <span class="o">=</span> <span class="n">bind</span> <span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">);</span>  
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="cm">/* We managed to bind successfully! */</span>  
            <span class="k">break</span><span class="p">;</span>  
        <span class="p">}</span>  
        <span class="n">close</span> <span class="p">(</span><span class="n">sfd</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">rp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Could not bind</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>  
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="n">freeaddrinfo</span> <span class="p">(</span><span class="n">result</span><span class="p">);</span>  
    <span class="k">return</span> <span class="n">sfd</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="c1">//函数  </span>
<span class="c1">//功能:设置socket为非阻塞的  </span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">make_socket_non_blocking</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sfd</span><span class="p">)</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>  
    <span class="c1">//得到文件状态标志  </span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span> <span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span>  
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="c1">//设置文件状态标志  </span>
    <span class="n">flags</span> <span class="o">|=</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>  
    <span class="n">s</span> <span class="o">=</span> <span class="n">fcntl</span> <span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;fcntl&quot;</span><span class="p">);</span>  
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  
    <span class="p">}</span>  
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
<span class="p">}</span>  
<span class="c1">//端口由参数argv[1]指定  </span>
    <span class="kt">int</span>  <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>  
<span class="p">{</span>  
    <span class="kt">int</span> <span class="n">sfd</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>  
    <span class="kt">int</span> <span class="n">efd</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Usage: %s [port]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>  
        <span class="n">exit</span> <span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>  
    <span class="p">}</span>  
    <span class="n">sfd</span> <span class="o">=</span> <span class="n">create_and_bind</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">sfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="n">abort</span> <span class="p">();</span>  
    <span class="n">s</span> <span class="o">=</span> <span class="n">make_socket_non_blocking</span> <span class="p">(</span><span class="n">sfd</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="n">abort</span> <span class="p">();</span>  
    <span class="n">s</span> <span class="o">=</span> <span class="n">listen</span> <span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">SOMAXCONN</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;listen&quot;</span><span class="p">);</span>  
        <span class="n">abort</span> <span class="p">();</span>  
    <span class="p">}</span>  
    <span class="c1">//除了参数size被忽略外,此函数和epoll_create完全相同  </span>
    <span class="n">efd</span> <span class="o">=</span> <span class="n">epoll_create1</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">efd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;epoll_create&quot;</span><span class="p">);</span>  
        <span class="n">abort</span> <span class="p">();</span>  
    <span class="p">}</span>  
    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">sfd</span><span class="p">;</span>  
    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span><span class="c1">//读入,边缘触发方式  </span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">efd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">sfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;epoll_ctl&quot;</span><span class="p">);</span>  
        <span class="n">abort</span> <span class="p">();</span>  
    <span class="p">}</span>  
    <span class="cm">/* Buffer where events are returned */</span>  
    <span class="n">events</span> <span class="o">=</span> <span class="n">calloc</span> <span class="p">(</span><span class="n">MAXEVENTS</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">event</span><span class="p">);</span>  
    <span class="cm">/* The event loop */</span>  
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
    <span class="p">{</span>  
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>  
        <span class="n">n</span> <span class="o">=</span> <span class="n">epoll_wait</span> <span class="p">(</span><span class="n">efd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAXEVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
        <span class="p">{</span>  
            <span class="k">if</span> <span class="p">((</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="o">||</span>  
                    <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="o">||</span>  
                    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)))</span>  
            <span class="p">{</span>  
                <span class="cm">/* An error has occured on this fd, or the socket is not </span>
<span class="cm">                     ready for reading (why were we notified then?) */</span>  
                <span class="n">fprintf</span> <span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;epoll error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>  
                <span class="n">close</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>  
                <span class="k">continue</span><span class="p">;</span>  
            <span class="p">}</span>  
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sfd</span> <span class="o">==</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">)</span>  
            <span class="p">{</span>  
                <span class="cm">/* We have a notification on the listening socket, which </span>
<span class="cm">                     means one or more incoming connections. */</span>  
                <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
                <span class="p">{</span>  
                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">in_addr</span><span class="p">;</span>  
                    <span class="kt">socklen_t</span> <span class="n">in_len</span><span class="p">;</span>  
                    <span class="kt">int</span> <span class="n">infd</span><span class="p">;</span>  
                    <span class="kt">char</span> <span class="n">hbuf</span><span class="p">[</span><span class="n">NI_MAXHOST</span><span class="p">],</span> <span class="n">sbuf</span><span class="p">[</span><span class="n">NI_MAXSERV</span><span class="p">];</span>  
                    <span class="n">in_len</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="n">in_addr</span><span class="p">;</span>  
                    <span class="n">infd</span> <span class="o">=</span> <span class="n">accept</span> <span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in_len</span><span class="p">);</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">infd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="k">if</span> <span class="p">((</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="o">||</span>  
                                <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">))</span>  
                        <span class="p">{</span>  
                            <span class="cm">/* We have processed all incoming </span>
<span class="cm">                                 connections. */</span>  
                            <span class="k">break</span><span class="p">;</span>  
                        <span class="p">}</span>  
                        <span class="k">else</span>  
                        <span class="p">{</span>  
                            <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;accept&quot;</span><span class="p">);</span>  
                            <span class="k">break</span><span class="p">;</span>  
                        <span class="p">}</span>  
                    <span class="p">}</span>  
                    <span class="c1">//将地址转化为主机名或者服务名  </span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">getnameinfo</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">in_addr</span><span class="p">,</span> <span class="n">in_len</span><span class="p">,</span>  
                            <span class="n">hbuf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">hbuf</span><span class="p">,</span>  
                            <span class="n">sbuf</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">sbuf</span><span class="p">,</span>  
                            <span class="n">NI_NUMERICHOST</span> <span class="o">|</span> <span class="n">NI_NUMERICSERV</span><span class="p">);</span><span class="c1">//flag参数:以数字名返回  </span>
                    <span class="c1">//主机地址和服务地址  </span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Accepted connection on descriptor %d &quot;</span>  
                                <span class="s">&quot;(host=%s, port=%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">infd</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">);</span>  
                    <span class="p">}</span>  
                    <span class="cm">/* Make the incoming socket non-blocking and add it to the </span>
<span class="cm">                         list of fds to monitor. */</span>  
                    <span class="n">s</span> <span class="o">=</span> <span class="n">make_socket_non_blocking</span> <span class="p">(</span><span class="n">infd</span><span class="p">);</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
                        <span class="n">abort</span> <span class="p">();</span>  
                    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">infd</span><span class="p">;</span>  
                    <span class="n">event</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>  
                    <span class="n">s</span> <span class="o">=</span> <span class="n">epoll_ctl</span> <span class="p">(</span><span class="n">efd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">infd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;epoll_ctl&quot;</span><span class="p">);</span>  
                        <span class="n">abort</span> <span class="p">();</span>  
                    <span class="p">}</span>  
                <span class="p">}</span>  
                <span class="k">continue</span><span class="p">;</span>  
            <span class="p">}</span>  
            <span class="k">else</span>  
            <span class="p">{</span>  
                <span class="cm">/* We have data on the fd waiting to be read. Read and </span>
<span class="cm">                     display it. We must read whatever data is available </span>
<span class="cm">                     completely, as we are running in edge-triggered mode </span>
<span class="cm">                     and won&#39;t get a notification again for the same </span>
<span class="cm">                     data. */</span>  
                <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
                <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
                <span class="p">{</span>  
                    <span class="kt">ssize_t</span> <span class="n">count</span><span class="p">;</span>  
                    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>  
                    <span class="n">count</span> <span class="o">=</span> <span class="n">read</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="cm">/* If errno == EAGAIN, that means we have read all </span>
<span class="cm">                             data. So go back to the main loop. */</span>  
                        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span>  
                        <span class="p">{</span>  
                            <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">);</span>  
                            <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
                        <span class="p">}</span>  
                        <span class="k">break</span><span class="p">;</span>  
                    <span class="p">}</span>  
                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="cm">/* End of file. The remote has closed the </span>
<span class="cm">                             connection. */</span>  
                        <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
                        <span class="k">break</span><span class="p">;</span>  
                    <span class="p">}</span>  
                    <span class="cm">/* Write the buffer to standard output */</span>  
                    <span class="n">s</span> <span class="o">=</span> <span class="n">write</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>  
                    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
                    <span class="p">{</span>  
                        <span class="n">perror</span> <span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">);</span>  
                        <span class="n">abort</span> <span class="p">();</span>  
                    <span class="p">}</span>  
                <span class="p">}</span>  
                <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span>  
                <span class="p">{</span>  
                    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Closed connection on descriptor %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>  
                            <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>  
                    <span class="cm">/* Closing the descriptor will make epoll remove it </span>
<span class="cm">                         from the set of descriptors which are monitored. */</span>  
                    <span class="n">close</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>  
                <span class="p">}</span>  
            <span class="p">}</span>  
        <span class="p">}</span>  
    <span class="p">}</span>  
    <span class="n">free</span> <span class="p">(</span><span class="n">events</span><span class="p">);</span>  
    <span class="n">close</span> <span class="p">(</span><span class="n">sfd</span><span class="p">);</span>  
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>  
<span class="p">}</span> 
</code></pre></div>
<p>运行方式：
在一个终端运行此程序：epoll.out PORT
另一个终端：telnet  127.0.0.1 PORT
<img src="http://img.blog.csdn.net/20130705124302250?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGlhanVuMDcwNjEyMjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="截图"></p>

<p>参考资料：
http://man7.org/linux/man-pages/man2/epoll<em>create.2.html
https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/
http://blog.csdn.net/sparkliang/article/details/4770655
《深入理解Nginx模块开发与架构解析》9.6小节
http://blog.csdn.net/eroswang/article/details/4481521
http://www.ccvita.com/515.html
http://blog.codingnow.com/2006/04/iocp</em>kqueue_epoll.html</p>

    </div>
    <hr>
    <div id="disqus_thread">
  <button type="button" name="liuwenyu" class="btn btn-default show-commend">显示评论</button>
</div>

  </div>
  <!-- 目录 -->
  <div id="content_table" style="position:fixed;right:20px;top:120px;display:none;">
    <div class="panel panel-success">
      <div class="panel-body" id="nav"></div>
    </div>
  </div>
</div>


          </div>
        </div>
      </div>
    </div>
  </div>
  <div style="position:fixed;right:20px;top:10px;">
  <button id="nav_btn" class="btn btn-lg" style="height:45px;width:45px;"><i class="fa fa-angle-left"></i></button>
</div>
<div style="position:fixed;right:20px;top:60px;">
  <button id="content_btn" class="btn btn-lg" style="height:45px;width:45px;"><i class="fa fa-angle-down"></i></button>
</div>
<script type="text/javascript" src="/public/js/jquery.js"></script>
<script type="text/javascript" src="/public/js/bootstrap.js"></script>
<script src="/public/js/jquery.pjax.js"></script>
<script src="/public/js/prettify/prettify.js"></script>
<script>
    $('a[href="#技术学习"]').tab('show');
</script>
<script src="/public/js/base.js"></script>
 
</body>
</html>
